<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>RMI反序列化(1)-调试分析源码 | IgTa's Blog</title><meta name="author" content="Zhang Haonan"><meta name="copyright" content="Zhang Haonan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RMI反序列化(1)-调试分析源码 Java RMI，即远程方法调用(Remote Method Invocation)，一种用于实现远程过程调用(RPC)(Remote procedure call)的Java API，能通过JRMP协议传输序列化数据，让某个Java虚拟机上的对象调用另⼀个Java虚拟机中对象上的方法。 本文通过调试源码，分析RMI服务端和客户端的构建流程。 RMI DemoR">
<meta property="og:type" content="article">
<meta property="og:title" content="RMI反序列化(1)-调试分析源码">
<meta property="og:url" content="https://igta24.github.io/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="IgTa's Blog">
<meta property="og:description" content="RMI反序列化(1)-调试分析源码 Java RMI，即远程方法调用(Remote Method Invocation)，一种用于实现远程过程调用(RPC)(Remote procedure call)的Java API，能通过JRMP协议传输序列化数据，让某个Java虚拟机上的对象调用另⼀个Java虚拟机中对象上的方法。 本文通过调试源码，分析RMI服务端和客户端的构建流程。 RMI DemoR">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://igta24.github.io/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/a.jpg">
<meta property="article:published_time" content="2022-12-20T12:55:31.000Z">
<meta property="article:modified_time" content="2022-12-21T16:01:16.510Z">
<meta property="article:author" content="Zhang Haonan">
<meta property="article:tag" content="Java安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://igta24.github.io/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/a.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://igta24.github.io/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RMI反序列化(1)-调试分析源码',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-22 00:01:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="IgTa's Blog" type="application/atom+xml">
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css');loadCss('https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css"></noscript></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">IgTa's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RMI反序列化(1)-调试分析源码</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-20T12:55:31.000Z" title="发表于 2022-12-20 20:55:31">2022-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-21T16:01:16.510Z" title="更新于 2022-12-22 00:01:16">2022-12-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AE%89%E5%85%A8/">Java安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RMI反序列化(1)-调试分析源码"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="RMI反序列化-1-调试分析源码"><a href="#RMI反序列化-1-调试分析源码" class="headerlink" title="RMI反序列化(1)-调试分析源码"></a>RMI反序列化(1)-调试分析源码</h1><p> Java RMI，即远程方法调用(Remote Method Invocation)，一种用于实现远程过程调用(RPC)(Remote procedure call)的Java API，能通过JRMP协议传输序列化数据，让某个Java虚拟机上的对象调用另⼀个Java虚拟机中对象上的方法。</p>
<p>本文通过调试源码，分析RMI服务端和客户端的构建流程。</p>
<h2 id="RMI-Demo"><a href="#RMI-Demo" class="headerlink" title="RMI Demo"></a>RMI Demo</h2><p>RMI Server分为三部分：</p>
<p>⼀个继承了 java.rmi.Remote 的接口，其中定义了我们要调用的远程方法，该方法需要抛出 RemoteException 异常；</p>
<p>⼀个实现了此接口的类，需要继承 UnicastRemoteObject 对象，或者手动调用<code>UnicastRemoteObject.exportObject(this, 0);</code>，两种方式本质是一样的；</p>
<p>⼀个主类，用来创建Registry，并将上面的类实例化后绑定到⼀个地址。这就是所谓的RMI Server。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"># IRemoteHelloWorld.java</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> {</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># RemoteHelloWorld.java</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">IRemoteHelloWorld</span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RemoteHelloWorld</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">        <span class="comment">// UnicastRemoteObject.exportObject(this, 0); //如果没有继承UnicastRemoteObject就需要手动发布</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">        System.out.println(<span class="string">"call from"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># RMIServer.java</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 创建远程对象</span></span><br><span class="line">        <span class="type">RemoteHelloWorld</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>();</span><br><span class="line">        <span class="comment">// 创建注册中心</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 绑定远程对象到注册中心</span></span><br><span class="line">        registry.bind(<span class="string">"Hello"</span>, h);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端也需要用到与服务端相同的接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"># IRemoteHelloWorld.java</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> {</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># RMIClient.java</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 获取注册中心</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">"127.0.0.1"</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 通过获取的注册中心对象得到远程对象</span></span><br><span class="line">        <span class="type">IRemoteHelloWorld</span> <span class="variable">hello</span> <span class="operator">=</span> (IRemoteHelloWorld) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="comment">// 调用远程对象上的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> hello.sayHello();</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>服务端和客户端之间的运作流程大致如下：</p>
<p>服务端创建注册中心，注册中心默认为1099端口；服务端创建远程对象并将远程对象和远程对象的端口绑定在注册中心上；客户端通过访问固定端口的注册中心，获取想要调用的类与其接口；客户端通过获取到的接口，传递参数给服务端，远程对象的方法在服务端上执行，最后将返回值返回给客户端。</p>
<p><img src="/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/1.png"></p>
<p>下文通过调试代码，深入分析RMI的创建和调用流程。</p>
<h2 id="服务端-创建远程对象"><a href="#服务端-创建远程对象" class="headerlink" title="服务端-创建远程对象"></a>服务端-创建远程对象</h2><p>本小节是对 <code>RemoteHelloWorld h = new RemoteHelloWorld();</code> 的调试。</p>
<p>调用父类 UnicastRemoteObject 的默认构造方法，然后调用 <code>UnicastRemoteObject(0)</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>.port = port;</span><br><span class="line">    exportObject((Remote) <span class="built_in">this</span>, port);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>跟进exportObject</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建了新的类对象 UnicastServerRef ，它代表远程对象的引用。这个类继承了Dispatcher接口，代表由它分发客户端的操作给远程对象。跟进 UnicastServerRef  的构造方法</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(<span class="type">int</span> port)</span> {</span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(port));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>出现了新类LiveRef，跟进其构造函数</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(<span class="type">int</span> port)</span> {</span><br><span class="line">    <span class="built_in">this</span>((<span class="keyword">new</span> <span class="title class_">ObjID</span>()), port);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, <span class="type">int</span> port)</span> {</span><br><span class="line">    <span class="built_in">this</span>(objID, TCPEndpoint.getLocalEndpoint(port), <span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, Endpoint endpoint, <span class="type">boolean</span> isLocal)</span> {</span><br><span class="line">    ep = endpoint;</span><br><span class="line">    id = objID;</span><br><span class="line">    <span class="built_in">this</span>.isLocal = isLocal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>出现了新类 TCPEndpoint，该类与TCP网络通信有关。跟进 <code>TCPEndpoint.getLocalEndpoint(port)</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TCPEndpoint <span class="title function_">getLocalEndpoint</span><span class="params">(<span class="type">int</span> port)</span> {</span><br><span class="line">    <span class="keyword">return</span> getLocalEndpoint(port, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TCPEndpoint <span class="title function_">getLocalEndpoint</span><span class="params">(<span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                                           RMIClientSocketFactory csf,</span></span><br><span class="line"><span class="params">                                           RMIServerSocketFactory ssf)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Find mapping for an endpoint key to the list of local unique</span></span><br><span class="line"><span class="comment">     * endpoints for this client/server socket factory pair (perhaps</span></span><br><span class="line"><span class="comment">     * null) for the specific port.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">TCPEndpoint</span> <span class="variable">ep</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (localEndpoints) {</span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">endpointKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(<span class="literal">null</span>, port, csf, ssf);</span><br><span class="line">        LinkedList&lt;TCPEndpoint&gt; epList = localEndpoints.get(endpointKey);</span><br><span class="line">        <span class="type">String</span> <span class="variable">localHost</span> <span class="operator">=</span> resampleLocalHost();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (epList == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Create new endpoint list.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ep = <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(localHost, port, csf, ssf);</span><br><span class="line">            epList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TCPEndpoint&gt;();</span><br><span class="line">            epList.add(ep);</span><br><span class="line">            ep.listenPort = port;</span><br><span class="line">            ep.transport = <span class="keyword">new</span> <span class="title class_">TCPTransport</span>(epList);</span><br><span class="line">            localEndpoints.put(endpointKey, epList);</span><br><span class="line">    ........</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ep;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最终的返回结果是构造好的 TCPEndPoint ，从下图可以看出，TCPEndPoint 的主要属性是域名、端口和TCPTransport。TCPTransport是真正处理网络请求的类，所以 TCPEndPoint 是绑定了域名、端口和TCPTransport的类。</p>
<p><img src="/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/2.png"></p>
<p>所以 LiveRef 其实就是封装了 TCPEndPoint 的类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, <span class="type">int</span> port)</span> {</span><br><span class="line">    <span class="built_in">this</span>(objID, TCPEndpoint.getLocalEndpoint(port), <span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LiveRef</span><span class="params">(ObjID objID, Endpoint endpoint, <span class="type">boolean</span> isLocal)</span> {</span><br><span class="line">    ep = endpoint;</span><br><span class="line">    id = objID;</span><br><span class="line">    <span class="built_in">this</span>.isLocal = isLocal;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>LiveRef 创建完成后返回 UnicastServerRef</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(LiveRef ref)</span> {</span><br><span class="line">    <span class="built_in">super</span>(ref);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastServerRef</span><span class="params">(<span class="type">int</span> port)</span> {</span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">LiveRef</span>(port));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在父类 UnicastRef 中进行赋值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastRef</span><span class="params">(LiveRef liveRef)</span> {</span><br><span class="line">	ref = liveRef;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结一下，创建了一个UnicastServerRef，它的属性ref是一个LiveRef，ref里面有一个TCPEndpoint叫ep，ep里面有个TCPTransport叫transport。</p>
<p>回到<code>UnicastRemoteObject#exportObject</code>，这里将刚创建好的 UnicastServerRef 赋值给了远程对象的属性ref。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// if obj extends UnicastRemoteObject, set its ref.</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) {</span><br><span class="line">        ((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>继续跟进</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> permanent)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    Class&lt;?&gt; implClass = impl.getClass();</span><br><span class="line">    Remote stub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalArgumentException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">            <span class="string">"remote object implements illegal remote interface"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) {</span><br><span class="line">        setSkeleton(impl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line">    ref.exportObject(target);</span><br><span class="line">    hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line">    <span class="keyword">return</span> stub;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>getClientRef()方法创建了UnicastRef的对象，并将刚创建的LiveRef赋值给其属性ref。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> RemoteRef <span class="title function_">getClientRef</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(ref);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UnicastRef</span><span class="params">(LiveRef liveRef)</span> {</span><br><span class="line">    ref = liveRef;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>继续跟进<code>stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</code></p>
<p>此处会判断远程对象RemoteHelloWorld是否实现了Remote接口，然后判断在jdk中是否存在该类的Stub类，即是否存在RemoteHelloWorld_Stub名称的类。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                 RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">    <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">{</span><br><span class="line">    Class&lt;?&gt; remoteClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        remoteClass = getRemoteClass(implClass);</span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex ) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">"object does not implement a remote interface: "</span> +</span><br><span class="line">            implClass.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">        !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> implClass.getClassLoader();</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] interfaces = getRemoteInterfaces(implClass);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(clientRef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* REMIND: private remote interfaces? */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Remote&gt;() {</span><br><span class="line">            <span class="keyword">public</span> Remote <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> (Remote) Proxy.newProxyInstance(loader,</span><br><span class="line">                                                       interfaces,</span><br><span class="line">                                                       handler);</span><br><span class="line">            }});</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalArgumentException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">"unable to create proxy"</span>, e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此处不存在，所以没有进入if语句里。后面的步骤其实就是创建了一个动态代理类，调用处理器是RemoteObjectInvocationHandler，把刚才创建的 UnicastRef 放了进去。</p>
<p><img src="/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/3.png"></p>
<p>回到<code>UnicastServerRef#exportObject</code>，接下来判断stub是否是远程对象，此处不会进入if语句</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> permanent)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    Class&lt;?&gt; implClass = impl.getClass();</span><br><span class="line">    Remote stub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalArgumentException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">            <span class="string">"remote object implements illegal remote interface"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) {</span><br><span class="line">        setSkeleton(impl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line">    ref.exportObject(target);</span><br><span class="line">    hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line">    <span class="keyword">return</span> stub;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>之后会创建Target，继续跟进</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Target</span><span class="params">(Remote impl, Dispatcher disp, Remote stub, ObjID id,</span></span><br><span class="line"><span class="params">              <span class="type">boolean</span> permanent)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>.weakImpl = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(impl, ObjectTable.reapQueue);</span><br><span class="line">    <span class="built_in">this</span>.disp = disp;</span><br><span class="line">    <span class="built_in">this</span>.stub = stub;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.acc = AccessController.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Fix for 4149366: so that downloaded parameter types unmarshalled</span></span><br><span class="line"><span class="comment">     * for this impl will be compatible with types known only to the</span></span><br><span class="line"><span class="comment">     * impl class's class loader (when it's not identical to the</span></span><br><span class="line"><span class="comment">     * exporting thread's context class loader), mark the impl's class</span></span><br><span class="line"><span class="comment">     * loader as the loader to use as the context class loader in the</span></span><br><span class="line"><span class="comment">     * server's dispatch thread while a call to this impl is being</span></span><br><span class="line"><span class="comment">     * processed (unless this exporting thread's context class loader is</span></span><br><span class="line"><span class="comment">     * a child of the impl's class loader, such as when a registry is</span></span><br><span class="line"><span class="comment">     * exported by an application, in which case this thread's context</span></span><br><span class="line"><span class="comment">     * class loader is preferred).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">threadContextLoader</span> <span class="operator">=</span></span><br><span class="line">        Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">serverLoader</span> <span class="operator">=</span> impl.getClass().getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (checkLoaderAncestry(threadContextLoader, serverLoader)) {</span><br><span class="line">        <span class="built_in">this</span>.ccl = threadContextLoader;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">this</span>.ccl = serverLoader;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.permanent = permanent;</span><br><span class="line">    <span class="keyword">if</span> (permanent) {</span><br><span class="line">        pinImpl();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现，target其实是远程对象、stub、UnicastServerRef等的一个总封装。</p>
<p>创建完成后，调用<code>ref.exportObject(target);</code>，即<code>LiveRef#exportObject</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    ep.exportObject(target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调用了<code>TCPEndPoint#exportObject</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    transport.exportObject(target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调用了<code>TCPTransport#exportObject</code>，此处开启了一个socket监听（随机创建了一个端口，同时开启了一个新线程，等待请求）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a server socket is listening, and count this</span></span><br><span class="line"><span class="comment">     * export while synchronized to prevent the server socket from</span></span><br><span class="line"><span class="comment">     * being closed due to concurrent unexports.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">        listen();</span><br><span class="line">        exportCount++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to add the Target to the exported object table; keep</span></span><br><span class="line"><span class="comment">     * counting this export (to keep server socket open) only if</span></span><br><span class="line"><span class="comment">     * that succeeds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ok</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="built_in">super</span>.exportObject(target);</span><br><span class="line">        ok = <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (!ok) {</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">                decrementExportCount();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>到此整个服务被暴露(exportObject方法)在对应端口上。</p>
<p>继续跟进<code>super.exportObject(target);</code>，即<code>TransPort#exportObject</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target target)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    target.setExportedTransport(<span class="built_in">this</span>);</span><br><span class="line">    ObjectTable.putTarget(target);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>setExportedTransport把对应的Transport放进Target</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setExportedTransport</span><span class="params">(Transport exportedTransport)</span> {</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.exportedTransport == <span class="literal">null</span>) {</span><br><span class="line">        <span class="built_in">this</span>.exportedTransport = exportedTransport;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>putTarget中主要是把储存对象、ip、端口等信息的 target 放进 ObjectTable 这个类的静态变量 objTable 里面，也即放进一个HashMap里。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putTarget</span><span class="params">(Target target)</span> <span class="keyword">throws</span> ExportException {</span><br><span class="line">    <span class="type">ObjectEndpoint</span> <span class="variable">oe</span> <span class="operator">=</span> target.getObjectEndpoint();</span><br><span class="line">    <span class="type">WeakRef</span> <span class="variable">weakImpl</span> <span class="operator">=</span> target.getWeakImpl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) {</span><br><span class="line">        DGCImpl.dgcLog.log(Log.VERBOSE, <span class="string">"add object "</span> + oe);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (tableLock) {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Do nothing if impl has already been collected (see 6597112). Check while</span></span><br><span class="line"><span class="comment">         * holding tableLock to ensure that Reaper cannot process weakImpl in between</span></span><br><span class="line"><span class="comment">         * null check and put/increment effects.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (target.getImpl() != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (objTable.containsKey(oe)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">                    <span class="string">"internal error: ObjID already in use"</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (implTable.containsKey(weakImpl)) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">"object already exported"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            objTable.put(oe, target);</span><br><span class="line">            implTable.put(weakImpl, target);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!target.isPermanent()) {</span><br><span class="line">                incrementKeepAliveCount();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/4.png"></p>
<p>其实创建远程对象的时候，还默认创建了一个DGCImpl_Stub，从图中也可以看出，objTable 里已经加入了这个垃圾回收相关的对象。</p>
<h2 id="服务端-创建注册中心"><a href="#服务端-创建注册中心" class="headerlink" title="服务端-创建注册中心"></a>服务端-创建注册中心</h2><p>本小节是对<code>Registry registry = LocateRegistry.createRegistry(1099);</code>这一行的调试。</p>
<p>跟进</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">createRegistry</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegistryImpl</span>(port);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建 RegistryImpl 对象，跟进其构造函数 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RegistryImpl</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (port == Registry.REGISTRY_PORT &amp;&amp; System.getSecurityManager() != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// grant permission for default port only.</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Void&gt;() {</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">                    <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line">                    setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">SocketPermission</span>(<span class="string">"localhost:"</span>+port, <span class="string">"listen,accept"</span>));</span><br><span class="line">        } <span class="keyword">catch</span> (PrivilegedActionException pae) {</span><br><span class="line">            <span class="keyword">throw</span> (RemoteException)pae.getException();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">LiveRef</span> <span class="variable">lref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveRef</span>(id, port);</span><br><span class="line">        setup(<span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(lref));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>System.getSecurityManager()</code> 默认为null，进入else语句。创建LiveRef并作为参数传入UnicastServerRef，跟进<code>RegistryImpl#setup</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(UnicastServerRef uref)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Server ref must be created and assigned before remote</span></span><br><span class="line"><span class="comment">     * object 'this' can be exported.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ref = uref;</span><br><span class="line">    uref.exportObject(<span class="built_in">this</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上一小节创建远程对象时，当创建完 LiveRef 并传入 UnicastServerRef 后，调用了<code>UnicastServerRef.exportObject(obj, null, false);</code>，此处的区别在于第三个参数为true。</p>
<p>继续跟进</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote impl, Object data,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> permanent)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    Class&lt;?&gt; implClass = impl.getClass();</span><br><span class="line">    Remote stub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        stub = Util.createProxy(implClass, getClientRef(), forceStubUse);</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalArgumentException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(</span><br><span class="line">            <span class="string">"remote object implements illegal remote interface"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (stub <span class="keyword">instanceof</span> RemoteStub) {</span><br><span class="line">        setSkeleton(impl);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Target</span>(impl, <span class="built_in">this</span>, stub, ref.getObjID(), permanent);</span><br><span class="line">    ref.exportObject(target);</span><br><span class="line">    hashToMethod_Map = hashToMethod_Maps.get(implClass);</span><br><span class="line">    <span class="keyword">return</span> stub;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>跟进 <code>Util.createProxy(implClass, getClientRef(), forceStubUse);</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                 RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">    <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">{</span><br><span class="line">    Class&lt;?&gt; remoteClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        remoteClass = getRemoteClass(implClass);</span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex ) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">            <span class="string">"object does not implement a remote interface: "</span> +</span><br><span class="line">            implClass.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">        !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">    }</span><br><span class="line">    .......</span><br></pre></td></tr></tbody></table></figure>

<p>与创建远程对象不同的是，sun包中存在 RegistryImpl_Stub 这个类</p>
<p><img src="/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/5.png"></p>
<p>所以会进入if语句，跟进 createStub，可以发现是直接通过反射实例化 RegistryImpl_Stub 这个类的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RemoteStub <span class="title function_">createStub</span><span class="params">(Class&lt;?&gt; remoteClass, RemoteRef ref)</span></span><br><span class="line">    <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">{</span><br><span class="line">    <span class="type">String</span> <span class="variable">stubname</span> <span class="operator">=</span> remoteClass.getName() + <span class="string">"_Stub"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure to use the local stub loader for the stub classes.</span></span><br><span class="line"><span class="comment">     * When loaded by the local loader the load path can be</span></span><br><span class="line"><span class="comment">     * propagated to remote clients, by the MarshalOutputStream/InStream</span></span><br><span class="line"><span class="comment">     * pickle methods</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Class&lt;?&gt; stubcl =</span><br><span class="line">            Class.forName(stubname, <span class="literal">false</span>, remoteClass.getClassLoader());</span><br><span class="line">        Constructor&lt;?&gt; cons = stubcl.getConstructor(stubConsParamTypes);</span><br><span class="line">        <span class="keyword">return</span> (RemoteStub) cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[] { ref });</span><br><span class="line">        ......</span><br></pre></td></tr></tbody></table></figure>

<p>RegistryImpl_Stub 继承了 RemoteStub，所以会进入 setSkeleton 方法，该方法中调用了<code>Util.createSkeleton</code>，跟进</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSkeleton</span><span class="params">(Remote impl)</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">    <span class="keyword">if</span> (!withoutSkeletons.containsKey(impl.getClass())) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            skel = Util.createSkeleton(impl);</span><br><span class="line">    .......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">static</span> Skeleton <span class="title function_">createSkeleton</span><span class="params">(Remote object)</span></span><br><span class="line">    <span class="keyword">throws</span> SkeletonNotFoundException</span><br><span class="line">{</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        cl = getRemoteClass(object.getClass());</span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex ) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(</span><br><span class="line">            <span class="string">"object does not implement a remote interface: "</span> +</span><br><span class="line">            object.getClass().getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now try to load the skeleton based ont he name of the class</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">skelname</span> <span class="operator">=</span> cl.getName() + <span class="string">"_Skel"</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Class&lt;?&gt; skelcl = Class.forName(skelname, <span class="literal">false</span>, cl.getClassLoader());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Skeleton)skelcl.newInstance();</span><br><span class="line">    ......</span><br></pre></td></tr></tbody></table></figure>

<p>和 createStub 方法类似，此处直接反射生成了 RegistryImpl_Skel 的实例化对象。</p>
<p>之后的步骤就与创建远程对象基本一致了，创建并发布 Target 这个总封装。然后把 Target 放进 ObjectTable 这个类的静态变量 objTable(一个静态的HashMap)里面。</p>
<p><img src="/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/6.png"></p>
<p>可以发现，注册中心其实就相当于一个特殊的远程对象，只不过注册中心不是动态代理生成的，而是直接实例化jdk中自带的类。</p>
<h2 id="服务端-在注册中心中绑定远程对象"><a href="#服务端-在注册中心中绑定远程对象" class="headerlink" title="服务端-在注册中心中绑定远程对象"></a>服务端-在注册中心中绑定远程对象</h2><p>本小节是对<code>registry.bind("Hello", h);</code>的调试。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span><br><span class="line">{</span><br><span class="line">    checkAccess(<span class="string">"Registry.bind"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (bindings) {</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">curr</span> <span class="operator">=</span> bindings.get(name);</span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>(name);</span><br><span class="line">        bindings.put(name, obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在 checkAccess 中进行了一些安全检查，注册中心必须跟服务端在一台机子上（在jdk低版本中没有这个限制）。</p>
<p>然后把名字和远程对象放入了 bindings 这个Hashtable 中。</p>
<p><img src="/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/7.png"></p>
<p>至此，RMI服务端构建完成。接下来分析客户端。</p>
<h2 id="客户端-获取注册中心"><a href="#客户端-获取注册中心" class="headerlink" title="客户端-获取注册中心"></a>客户端-获取注册中心</h2><p>本小节分析<code>Registry registry = LocateRegistry.getRegistry("127.0.0.1", 1099);</code>这一行。</p>
<p>跟进</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> getRegistry(host, port, <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>继续跟进</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                                   RMIClientSocketFactory csf)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port &lt;= <span class="number">0</span>)</span><br><span class="line">        port = Registry.REGISTRY_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (host == <span class="literal">null</span> || host.length() == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// If host is blank (as returned by "file:" URL in 1.0.2 used in</span></span><br><span class="line">        <span class="comment">// java.rmi.Naming), try to convert to real local host name so</span></span><br><span class="line">        <span class="comment">// that the RegistryImpl's checkAccess will not fail.</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            host = java.net.InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="comment">// If that failed, at least try "" (localhost) anyway...</span></span><br><span class="line">            host = <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create a proxy for the registry with the given host, port, and</span></span><br><span class="line"><span class="comment">     * client socket factory.  If the supplied client socket factory is</span></span><br><span class="line"><span class="comment">     * null, then the ref type is a UnicastRef, otherwise the ref type</span></span><br><span class="line"><span class="comment">     * is a UnicastRef2.  If the property</span></span><br><span class="line"><span class="comment">     * java.rmi.server.ignoreStubClasses is true, then the proxy</span></span><br><span class="line"><span class="comment">     * returned is an instance of a dynamic proxy class that implements</span></span><br><span class="line"><span class="comment">     * the Registry interface; otherwise the proxy returned is an</span></span><br><span class="line"><span class="comment">     * instance of the pregenerated stub class for RegistryImpl.</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LiveRef</span>(<span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port, csf, <span class="literal">null</span>),</span><br><span class="line">                    <span class="literal">false</span>);</span><br><span class="line">    <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span></span><br><span class="line">        (csf == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(liveRef) : <span class="keyword">new</span> <span class="title class_">UnicastRef2</span>(liveRef);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Registry) Util.createProxy(RegistryImpl.class, ref, <span class="literal">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过传入的ip和host创建LiveRef，然后用它创建了UnicastRef（服务端创建的是UnicastServerRef），再然后调用<code>Util.createProxy</code>创建了 RegistryImpl_Stub 对象。</p>
<p>所以这个注册中心的对象是在客户端本地创建的，并未与服务端或注册中心进行网络通信。</p>
<h2 id="客户端-查找远程对象"><a href="#客户端-查找远程对象" class="headerlink" title="客户端-查找远程对象"></a>客户端-查找远程对象</h2><p>这一小节是对<code>IRemoteHelloWorld hello = (IRemoteHelloWorld) registry.lookup("Hello");</code>这一行的调试。</p>
<p>registry是 RegistryImpl_Stub 类的对象，跟进其lookup方法。</p>
<p>先总体看一下，先是通过newCall方法建立与注册中心的连接，再通过invoke方法传递序列化的查询内容，再然后将服务端返回的结果反序列化读取，那么这里就存在一个反序列化点。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AccessException, NotBoundException, RemoteException {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">            var3.writeObject(var1);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException var17) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling arguments"</span>, var17);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">        Remote var22;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ObjectInput</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getInputStream();</span><br><span class="line">            var22 = (Remote)var4.readObject();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException var14) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling return"</span>, var14);</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException var15) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling return"</span>, var15);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="built_in">this</span>.ref.done(var2);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var22;</span><br><span class="line">    } <span class="keyword">catch</span> (RuntimeException var18) {</span><br><span class="line">        <span class="keyword">throw</span> var18;</span><br><span class="line">    } <span class="keyword">catch</span> (RemoteException var19) {</span><br><span class="line">        <span class="keyword">throw</span> var19;</span><br><span class="line">    } <span class="keyword">catch</span> (NotBoundException var20) {</span><br><span class="line">        <span class="keyword">throw</span> var20;</span><br><span class="line">    } <span class="keyword">catch</span> (Exception var21) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">"undeclared checked exception"</span>, var21);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>跟进<code>UnicastRef#newCall</code>，该方法发起了一个请求，并与注册中心建立连接。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RemoteCall <span class="title function_">newCall</span><span class="params">(RemoteObject obj, Operation[] ops, <span class="type">int</span> opnum,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> hash)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    clientRefLog.log(Log.BRIEF, <span class="string">"get connection"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ref.getChannel().newConnection();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        clientRefLog.log(Log.VERBOSE, <span class="string">"create call context"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* log information about the outgoing call */</span></span><br><span class="line">        <span class="keyword">if</span> (clientCallLog.isLoggable(Log.VERBOSE)) {</span><br><span class="line">            logClientCall(obj, ops[opnum]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), opnum, hash);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            marshalCustomCallData(call.getOutputStream());</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshaling "</span> +</span><br><span class="line">                                       <span class="string">"custom call data"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> call;</span><br><span class="line">    } <span class="keyword">catch</span> (RemoteException e) {</span><br><span class="line">        ref.getChannel().free(conn, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>随后，lookup方法中，把需要查找的远程对象名序列化，并传入<code>UnicastRef#invoke</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(RemoteCall call)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        clientRefLog.log(Log.VERBOSE, <span class="string">"execute call"</span>);</span><br><span class="line"></span><br><span class="line">        call.executeCall();</span><br><span class="line">    ......</span><br></pre></td></tr></tbody></table></figure>

<p>调用了<code>StreamRemoteCall#executeCall</code>，该方法发起与服务端的网络通信。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="type">byte</span> returnType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read result header</span></span><br><span class="line">    <span class="type">DGCAckHandler</span> <span class="variable">ackHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="literal">null</span>) {</span><br><span class="line">            ackHandler = out.getDGCAckHandler();</span><br><span class="line">        }</span><br><span class="line">        releaseOutputStream();</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line">        <span class="type">byte</span> <span class="variable">op</span> <span class="operator">=</span> rd.readByte();</span><br><span class="line">        <span class="keyword">if</span> (op != TransportConstants.Return) {</span><br><span class="line">            <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) {</span><br><span class="line">                Transport.transportLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">"transport return code invalid: "</span> + op);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Transport return code invalid"</span>);</span><br><span class="line">        }</span><br><span class="line">        getInputStream();</span><br><span class="line">        returnType = in.readByte();</span><br><span class="line">        in.readID();        <span class="comment">// id for DGC acknowledgement</span></span><br><span class="line">    } <span class="keyword">catch</span> (UnmarshalException e) {</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Error unmarshaling return header"</span>,</span><br><span class="line">                                     e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (ackHandler != <span class="literal">null</span>) {</span><br><span class="line">            ackHandler.release();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read return value</span></span><br><span class="line">    <span class="keyword">switch</span> (returnType) {</span><br><span class="line">    <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">        Object ex;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            ex = in.readObject();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Error unmarshaling return"</span>, e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// An exception should have been received,</span></span><br><span class="line">        <span class="comment">// if so throw it, else flag error</span></span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> Exception) {</span><br><span class="line">            exceptionReceivedFromServer((Exception) ex);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Return type not Exception"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Exception is thrown before fallthrough can occur</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (Transport.transportLog.isLoggable(Log.BRIEF)) {</span><br><span class="line">            Transport.transportLog.log(Log.BRIEF,</span><br><span class="line">                <span class="string">"return code invalid: "</span> + returnType);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"Return code invalid"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>服务端返回的结果，如果是异常<code>TransportConstants.ExceptionalReturn</code>，会调用<code>in.readObject()</code>反序列化，所以这是一个可攻击点。而实际上，所有Stub都是通过调用<code>UnicastRef#invoke</code>进行网络通信的，所以当客户端的Stub对恶意服务端发起请求时，都有可能被攻击。</p>
<p>接下来看服务端的注册中心是怎么处理客户端发送的请求的。</p>
<p>这里省略了服务端监听-接受客户端请求的过程，客户端发起的lookup查询，最终是由服务端的<code>RegistryImpl_Skel#dispatch</code>处理，dispatch方法中有安全检查，远程调用只能使用lookup和list方法，bind、rebind和unbind方法只能本地调用。switch语句会根据客户端发起的请求类型执行对应的回复，此时var3为2表示执行lookup方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="type">int</span> var3, <span class="type">long</span> var4)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">if</span> (var4 != <span class="number">4905912898345647071L</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonMismatchException</span>(<span class="string">"interface hash mismatch"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">RegistryImpl</span> <span class="variable">var6</span> <span class="operator">=</span> (RegistryImpl)var1;</span><br><span class="line">        String var7;</span><br><span class="line">        ObjectInput var8;</span><br><span class="line">        ObjectInput var9;</span><br><span class="line">        Remote var80;</span><br><span class="line">        <span class="keyword">switch</span> (var3) {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                RegistryImpl.checkAccess(<span class="string">"Registry.bind"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var9 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var9.readObject();</span><br><span class="line">                    var80 = (Remote)var9.readObject();</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException | IOException var77) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var77);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                var6.bind(var7, var80);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var76) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var76);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                var2.releaseInputStream();</span><br><span class="line">                String[] var79 = var6.list();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var81</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var81.writeObject(var79);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var75) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var75);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var8 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var8.readObject();</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException | IOException var73) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var73);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                var80 = var6.lookup(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var82</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var82.writeObject(var80);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var72) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var72);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                RegistryImpl.checkAccess(<span class="string">"Registry.rebind"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var9 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var9.readObject();</span><br><span class="line">                    var80 = (Remote)var9.readObject();</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException | IOException var70) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var70);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                var6.rebind(var7, var80);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var69) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var69);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                RegistryImpl.checkAccess(<span class="string">"Registry.unbind"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var8 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var8.readObject();</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException | IOException var67) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var67);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                var6.unbind(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var66) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var66);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"invalid method number"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现，注册中心会对客户端（如lookup方法）或者服务端（如bind方法）发送的数据进行反序列化，并将结果序列化返回，所以这里也有可能存在反序列化漏洞，在旧的JDK版本中，服务端和注册中心可以不在同一台服务器上，所以服务端也可以攻击注册中心。</p>
<h2 id="客户端-调用远程方法"><a href="#客户端-调用远程方法" class="headerlink" title="客户端-调用远程方法"></a>客户端-调用远程方法</h2><p>本小节分析<code>String ret = hello.sayHello();</code>这一行。</p>
<p>远程对象是一个动态代理，所以会触发<code>RemoteObjectInvocationHandler#invoke</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (! Proxy.isProxyClass(proxy.getClass())) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"not a proxy"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Proxy.getInvocationHandler(proxy) != <span class="built_in">this</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"handler mismatch"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) {</span><br><span class="line">        <span class="keyword">return</span> invokeObjectMethod(proxy, method, args);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"finalize"</span>.equals(method.getName()) &amp;&amp; method.getParameterCount() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        !allowFinalizeInvocation) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// ignore</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> invokeRemoteMethod(proxy, method, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>会进入else语句，继续跟进</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                  Method method,</span></span><br><span class="line"><span class="params">                                  Object[] args)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (!(proxy <span class="keyword">instanceof</span> Remote)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">"proxy not Remote instance"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                          getMethodHash(method));</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> RuntimeException)) {</span><br><span class="line">            Class&lt;?&gt; cl = proxy.getClass();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                method = cl.getMethod(method.getName(),</span><br><span class="line">                                      method.getParameterTypes());</span><br><span class="line">            } <span class="keyword">catch</span> (NoSuchMethodException nsme) {</span><br><span class="line">                <span class="keyword">throw</span> (IllegalArgumentException)</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>().initCause(nsme);</span><br><span class="line">            }</span><br><span class="line">            Class&lt;?&gt; thrownType = e.getClass();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; declaredType : method.getExceptionTypes()) {</span><br><span class="line">                <span class="keyword">if</span> (declaredType.isAssignableFrom(thrownType)) {</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            e = <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">"unexpected exception"</span>, e);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调用了<code>UnicastRef#invoke</code>，而这里同样调用了<code>call.executeCall()</code>，所以此时客户端也有可能遭到恶意服务端通过返回特定异常进行的攻击。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Remote obj,</span></span><br><span class="line"><span class="params">                         Method method,</span></span><br><span class="line"><span class="params">                         Object[] params,</span></span><br><span class="line"><span class="params">                         <span class="type">long</span> opnum)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) {</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">"method: "</span> + method);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientCallLog.isLoggable(Log.VERBOSE)) {</span><br><span class="line">            logClientCall(obj, method);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ref.getChannel().newConnection();</span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reuse</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the call connection is "reused" early, remember not to</span></span><br><span class="line"><span class="comment">         * reuse again.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">alreadyFreed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) {</span><br><span class="line">                clientRefLog.log(Log.VERBOSE, <span class="string">"opnum = "</span> + opnum);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// create call context</span></span><br><span class="line">            call = <span class="keyword">new</span> <span class="title class_">StreamRemoteCall</span>(conn, ref.getObjID(), -<span class="number">1</span>, opnum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// marshal parameters</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getOutputStream();</span><br><span class="line">                marshalCustomCallData(out);</span><br><span class="line">                Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) {</span><br><span class="line">                    marshalValue(types[i], params[i], out);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                clientRefLog.log(Log.BRIEF,</span><br><span class="line">                    <span class="string">"IOException marshalling arguments: "</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling arguments"</span>, e);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unmarshal return</span></span><br><span class="line">            call.executeCall();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">                Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">                <span class="keyword">if</span> (rtype == <span class="keyword">void</span>.class)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">ObjectInput</span> <span class="variable">in</span> <span class="operator">=</span> call.getInputStream();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* StreamRemoteCall.done() does not actually make use</span></span><br><span class="line"><span class="comment">                 * of conn, therefore it is safe to reuse this</span></span><br><span class="line"><span class="comment">                 * connection before the dirty call is sent for</span></span><br><span class="line"><span class="comment">                 * registered refs.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> unmarshalValue(rtype, in);</span><br><span class="line">        ......</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现，如果返回值的类型不为void，则会调用unmarshalValue。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title function_">unmarshalValue</span><span class="params">(Class&lt;?&gt; type, ObjectInput in)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (type.isPrimitive()) {</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">int</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(in.readInt());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Boolean.valueOf(in.readBoolean());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">byte</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Byte.valueOf(in.readByte());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">char</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Character.valueOf(in.readChar());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Short.valueOf(in.readShort());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Long.valueOf(in.readLong());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">float</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Float.valueOf(in.readFloat());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">double</span>.class) {</span><br><span class="line">            <span class="keyword">return</span> Double.valueOf(in.readDouble());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">"Unrecognized primitive type: "</span> + type);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> in.readObject();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可见，返回的序列化数据类型满足条件即可触发反序列化。</p>
<p>服务端对客户端发送的调用远程方法请求，最终是在<code>UnicastServerRef#dispatch</code>中进行处理的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote obj, RemoteCall call)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// positive operation number in 1.1 stubs;</span></span><br><span class="line">    <span class="comment">// negative version number in 1.2 stubs and beyond...</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">long</span> op;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// read remote call header</span></span><br><span class="line">        ObjectInput in;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            in = call.getInputStream();</span><br><span class="line">            num = in.readInt();</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (skel != <span class="literal">null</span>) {</span><br><span class="line">                    oldDispatch(obj, call, num);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                        <span class="string">"skeleton class not found but required "</span> +</span><br><span class="line">                        <span class="string">"for client version"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            op = in.readLong();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception readEx) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling call header"</span>,</span><br><span class="line">                                         readEx);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Since only system classes (with null class loaders) will be on</span></span><br><span class="line"><span class="comment">         * the execution stack during parameter unmarshalling for the 1.2</span></span><br><span class="line"><span class="comment">         * stub protocol, tell the MarshalInputStream not to bother trying</span></span><br><span class="line"><span class="comment">         * to resolve classes using its superclasses's default method of</span></span><br><span class="line"><span class="comment">         * consulting the first non-null class loader on the stack.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">MarshalInputStream</span> <span class="variable">marshalStream</span> <span class="operator">=</span> (MarshalInputStream) in;</span><br><span class="line">        marshalStream.skipDefaultResolveClass();</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> hashToMethod_Map.get(op);</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"unrecognized method hash: "</span> +</span><br><span class="line">                <span class="string">"method not supported by remote object"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if calls are being logged, write out object id and operation</span></span><br><span class="line">        logCall(obj, method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// unmarshal parameters</span></span><br><span class="line">        Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line">        Object[] params = <span class="keyword">new</span> <span class="title class_">Object</span>[types.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            unmarshalCustomCallData(in);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) {</span><br><span class="line">                params[i] = unmarshalValue(types[i], in);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (java.io.IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                <span class="string">"error unmarshalling arguments"</span>, e);</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(</span><br><span class="line">                <span class="string">"error unmarshalling arguments"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            call.releaseInputStream();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make upcall on remote object</span></span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            result = method.invoke(obj, params);</span><br><span class="line">        } <span class="keyword">catch</span> (InvocationTargetException e) {</span><br><span class="line">            <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// marshal return value</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">true</span>);</span><br><span class="line">            Class&lt;?&gt; rtype = method.getReturnType();</span><br><span class="line">            <span class="keyword">if</span> (rtype != <span class="keyword">void</span>.class) {</span><br><span class="line">                marshalValue(rtype, result, out);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, ex);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This throw is problematic because when it is caught below,</span></span><br><span class="line"><span class="comment">             * we attempt to marshal it back to the client, but at this</span></span><br><span class="line"><span class="comment">             * point, a "normal return" has already been indicated,</span></span><br><span class="line"><span class="comment">             * so marshalling an exception will corrupt the stream.</span></span><br><span class="line"><span class="comment">             * This was the case with skeletons as well; there is no</span></span><br><span class="line"><span class="comment">             * immediately obvious solution without a protocol change.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable e) {</span><br><span class="line">        logCallException(e);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutput</span> <span class="variable">out</span> <span class="operator">=</span> call.getResultStream(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Error) {</span><br><span class="line">            e = <span class="keyword">new</span> <span class="title class_">ServerError</span>(</span><br><span class="line">                <span class="string">"Error occurred in server thread"</span>, (Error) e);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RemoteException) {</span><br><span class="line">            e = <span class="keyword">new</span> <span class="title class_">ServerException</span>(</span><br><span class="line">                <span class="string">"RemoteException occurred in server thread"</span>,</span><br><span class="line">                (Exception) e);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (suppressStackTraces) {</span><br><span class="line">            clearStackTraces(e);</span><br><span class="line">        }</span><br><span class="line">        out.writeObject(e);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        call.releaseInputStream(); <span class="comment">// in case skeleton doesn't</span></span><br><span class="line">        call.releaseOutputStream();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端获取注册中心时，也会进入该方法，但是会进入第一个if语句，调用<code>oldDispatch(obj, call, num);</code>，而这里则会跳过if语句，执行后续的unmarshalValue，所以这里也存在反序列化点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在RMI中，是通过动态代理实现网络通信的，这样的话对程序员来说，只需要专注远程对象本身，而不需要关心通信的细节。服务端和客户端通过Skeleton和Stub这两个动态代理对象，通过JRMP协议进行序列化数据的传输通信。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://halfblue.github.io/2021/10/26/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E4%B8%89%E9%A1%BE%E8%8C%85%E5%BA%90-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">RMI反序列化漏洞之三顾茅庐-流程分析 | Halfblue</a></p>
<p><a target="_blank" rel="noopener" href="http://www.men9da.cn/2022/03/10/%E9%80%9A%E8%BF%87%E8%B0%83%E8%AF%95%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%88%86%E6%9E%90RMI%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">通过调试源码深入理解分析RMI运行机制(长文) | Mengd@ (men9da.cn)</a></p>
<p>Java安全漫谈 - 04.RMI篇(1)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://igta24.github.io">Zhang Haonan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://igta24.github.io/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/">https://igta24.github.io/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://igta24.github.io" target="_blank">IgTa's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%AE%89%E5%85%A8/">Java安全</a></div><div class="post_share"><div class="social-share" data-image="/2022/12/20/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81/a.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/28/Java%E5%AE%89%E5%85%A8-JNDI%E6%B3%A8%E5%85%A5/"><img class="prev-cover" src="/2023/02/28/Java%E5%AE%89%E5%85%A8-JNDI%E6%B3%A8%E5%85%A5/hack.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java安全-JNDI注入</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-8-Shiro%E6%97%A0CC%E4%BE%9D%E8%B5%96%E4%B8%8B%E7%9A%84CB%E5%88%A9%E7%94%A8%E9%93%BE/"><img class="next-cover" src="/2022/11/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-8-Shiro%E6%97%A0CC%E4%BE%9D%E8%B5%96%E4%B8%8B%E7%9A%84CB%E5%88%A9%E7%94%A8%E9%93%BE/shiro.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java反序列化(8)-Shiro无CC依赖下的CB利用链</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/30/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-URLDNS%E9%93%BE%E5%88%86%E6%9E%90/" title="Java反序列化(1)-URLDNS链分析"><img class="cover" src="/img/code1.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-30</div><div class="title">Java反序列化(1)-URLDNS链分析</div></div></a></div><div><a href="/2022/11/03/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-2-CC1%E9%93%BE%E5%88%86%E6%9E%90/" title="Java反序列化(2)-CC1链分析"><img class="cover" src="/img/code2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-03</div><div class="title">Java反序列化(2)-CC1链分析</div></div></a></div><div><a href="/2022/11/11/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-3-%E4%BD%BF%E7%94%A8LazyMap%E6%9E%84%E9%80%A0CC1%E9%93%BE/" title="Java反序列化(3)-使用LazyMap构造CC1链"><img class="cover" src="/img/code3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-11</div><div class="title">Java反序列化(3)-使用LazyMap构造CC1链</div></div></a></div><div><a href="/2022/11/12/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-4-CC6%E9%93%BE%E5%88%86%E6%9E%90/" title="Java反序列化(4)-CC6链分析"><img class="cover" src="/2022/11/12/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-4-CC6%E9%93%BE%E5%88%86%E6%9E%90/cc6.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-12</div><div class="title">Java反序列化(4)-CC6链分析</div></div></a></div><div><a href="/2022/11/15/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-5-CC3%E9%93%BE%E5%88%86%E6%9E%90/" title="Java反序列化(5)-CC3链分析"><img class="cover" src="/2022/11/15/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-5-CC3%E9%93%BE%E5%88%86%E6%9E%90/cc.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-15</div><div class="title">Java反序列化(5)-CC3链分析</div></div></a></div><div><a href="/2023/02/28/Java%E5%AE%89%E5%85%A8-JNDI%E6%B3%A8%E5%85%A5/" title="Java安全-JNDI注入"><img class="cover" src="/2023/02/28/Java%E5%AE%89%E5%85%A8-JNDI%E6%B3%A8%E5%85%A5/hack.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="title">Java安全-JNDI注入</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">RMI反序列化(1)-调试分析源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI-Demo"><span class="toc-number">1.1.</span> <span class="toc-text">RMI Demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">服务端-创建远程对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%88%9B%E5%BB%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.3.</span> <span class="toc-text">服务端-创建注册中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-%E5%9C%A8%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B8%AD%E7%BB%91%E5%AE%9A%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.</span> <span class="toc-text">服务端-在注册中心中绑定远程对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E8%8E%B7%E5%8F%96%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.5.</span> <span class="toc-text">客户端-获取注册中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9F%A5%E6%89%BE%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.</span> <span class="toc-text">客户端-查找远程对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E8%B0%83%E7%94%A8%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">客户端-调用远程方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">1.9.</span> <span class="toc-text">参考文章</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">©2020 - 2023 By Zhang Haonan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="别点,痛" data-fontsize="15px" data-random="false" async="async"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/bundle.js"></script><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>